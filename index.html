<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Confetti Commandplex</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    
    /* Ensure scrolling works */
    .scroll-container {
      overflow-y: auto !important;
      -webkit-overflow-scrolling: touch;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // Lucide React icons as inline SVG components
    const Sparkles = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z" />
      </svg>
    );

    const Settings = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
      </svg>
    );

    const X = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
      </svg>
    );

    const Plus = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
      </svg>
    );

    const ConfettiGenerator = () => {
      const canvasRef = useRef(null);
      const animationRef = useRef(null);
      const particlesRef = useRef([]);
      
      const builtInShapes = [
        { id: 'rectangle', name: 'Rectangle', type: 'geometric' },
        { id: 'circle', name: 'Circle', type: 'geometric' },
        { id: 'star', name: 'Star', type: 'geometric' },
        { id: 'heart', name: 'Heart', type: 'geometric' },
        { id: 'triangle', name: 'Triangle', type: 'geometric' }
      ];
      
      const [customShapes, setCustomShapes] = useState([]);
      const [selectedShapes, setSelectedShapes] = useState(['rectangle', 'circle', 'star']);
      const [colors, setColors] = useState(['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F']);
      const [customColor, setCustomColor] = useState('#FF6B6B');
      const [burstPattern, setBurstPattern] = useState('explosion');
      const [reverseGravity, setReverseGravity] = useState(false);
      const [particleCount, setParticleCount] = useState(100);
      const [gravity, setGravity] = useState(0.3);
      const [spread, setSpread] = useState(8);
      const [showControls, setShowControls] = useState(true);
      const [buttonImage, setButtonImage] = useState('');
      const [newShapeName, setNewShapeName] = useState('');
      const [newShapeUrl, setNewShapeUrl] = useState('');
      const [showAddShape, setShowAddShape] = useState(false);
      
      const allShapes = [...builtInShapes, ...customShapes];
      
      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        
        const updateSize = () => {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
        };
        
        updateSize();
        window.addEventListener('resize', updateSize);
        return () => window.removeEventListener('resize', updateSize);
      }, []);
      
      const drawShape = (ctx, shape, x, y, size, rotation, color) => {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);
        ctx.fillStyle = color;
        
        switch (shape) {
          case 'rectangle':
            ctx.fillRect(-size/2, -size/2, size, size * 0.6);
            break;
            
          case 'circle':
            ctx.beginPath();
            ctx.arc(0, 0, size/2, 0, Math.PI * 2);
            ctx.fill();
            break;
            
          case 'star':
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
              const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
              const radius = i % 2 === 0 ? size/2 : size/4;
              const px = Math.cos(angle) * radius;
              const py = Math.sin(angle) * radius;
              if (i === 0) ctx.moveTo(px, py);
              else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
            break;
            
          case 'heart':
            ctx.beginPath();
            const topCurveHeight = size * 0.3;
            ctx.moveTo(0, topCurveHeight);
            ctx.bezierCurveTo(0, 0, -size/2, 0, -size/2, topCurveHeight);
            ctx.bezierCurveTo(-size/2, size * 0.5, 0, size * 0.7, 0, size);
            ctx.bezierCurveTo(0, size * 0.7, size/2, size * 0.5, size/2, topCurveHeight);
            ctx.bezierCurveTo(size/2, 0, 0, 0, 0, topCurveHeight);
            ctx.fill();
            break;
            
          case 'triangle':
            ctx.beginPath();
            ctx.moveTo(0, -size/2);
            ctx.lineTo(size/2, size/2);
            ctx.lineTo(-size/2, size/2);
            ctx.closePath();
            ctx.fill();
            break;
        }
        
        ctx.restore();
      };
      
      const createParticle = (canvas, particleIndex, totalParticles) => {
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const shape = selectedShapes[Math.floor(Math.random() * selectedShapes.length)];
        const shapeObj = allShapes.find(s => s.id === shape);
        const color = colors[Math.floor(Math.random() * colors.length)];
        const size = Math.random() * 15 + 10;
        
        let vx, vy, startX, startY;
        startX = centerX;
        startY = centerY;
        
        switch (burstPattern) {
          case 'explosion':
            // Classic radial burst in all directions
            const angle = Math.random() * Math.PI * 2;
            const velocity = Math.random() * spread + 2;
            vx = Math.cos(angle) * velocity;
            vy = Math.sin(angle) * velocity;
            break;
            
          case 'fountain':
            // Tight upward cone that arcs over and comes back down
            const fountainSpread = spread * 0.4; // Slightly wider for visibility
            vx = (Math.random() - 0.5) * fountainSpread;
            if (reverseGravity) {
              vy = -(Math.random() * spread * 0.8 + 4); // Moderate downward for reverse
            } else {
              vy = -(Math.random() * spread * 0.8 + 4); // Moderate upward - lets gravity bring it back!
            }
            break;
            
          case 'cascade':
            // Waterfall effect - starts from top, sweeps across
            const cascadeWidth = canvas.width * 0.6;
            const progress = particleIndex / totalParticles;
            startX = centerX - cascadeWidth/2 + (cascadeWidth * progress);
            startY = centerY - 100; // Start above center
            vx = (Math.random() - 0.5) * spread * 0.5;
            if (reverseGravity) {
              vy = -(Math.random() * 3 + 1); // Gentle upward for reverse
            } else {
              vy = Math.random() * 3 + 1; // Gentle downward
            }
            break;
            
          case 'spiral':
            // Spiral pattern - particles emit in rotating angles
            const spiralAngle = (particleIndex / totalParticles) * Math.PI * 4 + Math.random() * 0.3;
            const spiralRadius = (particleIndex / totalParticles) * spread * 2;
            const spiralVelocity = spread * 0.8;
            vx = Math.cos(spiralAngle) * spiralVelocity;
            vy = Math.sin(spiralAngle) * spiralVelocity;
            break;
            
          default:
            vx = (Math.random() - 0.5) * spread;
            vy = -(Math.random() * spread);
        }
        
        return {
          x: startX,
          y: startY,
          vx,
          vy,
          rotation: Math.random() * Math.PI * 2,
          rotationSpeed: (Math.random() - 0.5) * 0.2,
          size,
          color,
          shape: shapeObj?.type === 'geometric' ? shape : null,
          imageUrl: shapeObj?.type === 'image' ? shapeObj.url : null,
          image: null,
          alpha: 1,
          life: 1
        };
      };
      
      const animate = () => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const effectiveGravity = reverseGravity ? -gravity : gravity;
        
        particlesRef.current = particlesRef.current.filter(particle => {
          particle.vy += effectiveGravity;
          particle.x += particle.vx;
          particle.y += particle.vy;
          particle.rotation += particle.rotationSpeed;
          particle.life -= 0.004; // Slower fade - particles last longer!
          particle.alpha = particle.life;
          
          ctx.globalAlpha = particle.alpha;
          
          if (particle.shape) {
            drawShape(ctx, particle.shape, particle.x, particle.y, particle.size, particle.rotation, particle.color);
          } else if (particle.image && particle.image.complete) {
            ctx.save();
            ctx.translate(particle.x, particle.y);
            ctx.rotate(particle.rotation);
            ctx.drawImage(particle.image, -particle.size/2, -particle.size/2, particle.size, particle.size);
            ctx.restore();
          }
          
          ctx.globalAlpha = 1;
          
          // Keep particle alive if it's still visible and within generous bounds
          // Allow particles to go WAY above screen for fountain effect!
          return particle.life > 0 && 
                 particle.y > -500 &&  // Much more room above for fountain!
                 particle.y < canvas.height + 500 &&
                 particle.x > -200 && 
                 particle.x < canvas.width + 200;
        });
        
        animationRef.current = requestAnimationFrame(animate);
      };
      
      useEffect(() => {
        animate();
        return () => {
          if (animationRef.current) {
            cancelAnimationFrame(animationRef.current);
          }
        };
      }, [reverseGravity, gravity]);
      
      const triggerConfetti = () => {
        const canvas = canvasRef.current;
        if (!canvas || selectedShapes.length === 0) return;
        
        const newParticles = [];
        for (let i = 0; i < particleCount; i++) {
          const particle = createParticle(canvas, i, particleCount);
          
          if (particle.imageUrl) {
            particle.image = new Image();
            particle.image.src = particle.imageUrl;
          }
          
          newParticles.push(particle);
        }
        
        particlesRef.current = [...particlesRef.current, ...newParticles];
      };
      
      const toggleShape = (shapeId) => {
        setSelectedShapes(prev => 
          prev.includes(shapeId) 
            ? prev.filter(id => id !== shapeId)
            : [...prev, shapeId]
        );
      };
      
      const addCustomShape = () => {
        if (!newShapeName || !newShapeUrl) return;
        
        const newShape = {
          id: `custom-${Date.now()}`,
          name: newShapeName,
          type: 'image',
          url: newShapeUrl
        };
        
        setCustomShapes([...customShapes, newShape]);
        setNewShapeName('');
        setNewShapeUrl('');
        setShowAddShape(false);
      };
      
      const addColorToPalette = () => {
        if (!colors.includes(customColor)) {
          setColors([...colors, customColor]);
        }
      };
      
      return (
        <div className="w-full h-screen relative overflow-hidden bg-transparent">
          <canvas 
            ref={canvasRef}
            className="absolute inset-0 pointer-events-none"
          />
          
          <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-10">
            <button
              onClick={triggerConfetti}
              className="group relative overflow-hidden"
            >
              {buttonImage ? (
                <img 
                  src={buttonImage} 
                  alt="Trigger Confetti"
                  className="w-32 h-32 object-contain hover:scale-110 transition-transform cursor-pointer"
                />
              ) : (
                <div className="w-32 h-32 bg-gradient-to-br from-purple-500 to-pink-500 rounded-full flex items-center justify-center hover:scale-110 transition-transform shadow-2xl cursor-pointer">
                  <Sparkles className="w-16 h-16 text-white" />
                </div>
              )}
            </button>
          </div>
          
          {showControls && (
            <div 
              className="absolute top-4 right-4 w-96 bg-white/95 backdrop-blur rounded-2xl shadow-2xl z-20 flex flex-col"
              style={{ height: 'calc(100vh - 2rem)' }}
            >
              <div className="flex-shrink-0 flex items-center justify-between p-6 pb-4 border-b border-gray-200">
                <div className="flex items-center gap-2">
                  <Settings className="w-6 h-6 text-purple-600" />
                  <h2 className="text-2xl font-bold text-gray-800">Confetti Commandplexâ„¢</h2>
                </div>
                <button 
                  onClick={() => setShowControls(false)}
                  className="text-gray-500 hover:text-gray-700"
                >
                  <X className="w-6 h-6" />
                </button>
              </div>
              
              <div className="flex-1 scroll-container p-6 pt-4" style={{ overflowY: 'auto' }}>
                <div className="mb-6">
                  <h3 className="font-semibold text-gray-700 mb-3">Active Shapes</h3>
                  <div className="grid grid-cols-3 gap-2">
                    {allShapes.map(shape => (
                      <button
                        key={shape.id}
                        onClick={() => toggleShape(shape.id)}
                        className={`p-3 rounded-lg border-2 transition-all ${
                          selectedShapes.includes(shape.id)
                            ? 'border-purple-500 bg-purple-50'
                            : 'border-gray-200 bg-white hover:border-purple-300'
                        }`}
                      >
                        <div className="text-sm font-medium truncate">{shape.name}</div>
                      </button>
                    ))}
                  </div>
                  
                  <button
                    onClick={() => setShowAddShape(!showAddShape)}
                    className="mt-3 w-full flex items-center justify-center gap-2 p-3 border-2 border-dashed border-purple-300 rounded-lg hover:border-purple-500 transition-colors"
                  >
                    <Plus className="w-4 h-4" />
                    <span className="text-sm font-medium">Add Custom Shape</span>
                  </button>
                  
                  {showAddShape && (
                    <div className="mt-3 p-4 bg-purple-50 rounded-lg space-y-3">
                      <input
                        type="text"
                        placeholder="Shape name"
                        value={newShapeName}
                        onChange={(e) => setNewShapeName(e.target.value)}
                        className="w-full px-3 py-2 border border-purple-200 rounded-lg"
                      />
                      <input
                        type="text"
                        placeholder="Image URL (PNG with transparency)"
                        value={newShapeUrl}
                        onChange={(e) => setNewShapeUrl(e.target.value)}
                        className="w-full px-3 py-2 border border-purple-200 rounded-lg"
                      />
                      <button
                        onClick={addCustomShape}
                        className="w-full bg-purple-500 text-white py-2 rounded-lg hover:bg-purple-600 transition-colors"
                      >
                        Add Shape
                      </button>
                    </div>
                  )}
                </div>
                
                <div className="mb-6">
                  <h3 className="font-semibold text-gray-700 mb-3">Color Palette</h3>
                  <div className="flex flex-wrap gap-2 mb-3">
                    {colors.map((color, idx) => (
                      <div
                        key={idx}
                        className="w-10 h-10 rounded-lg shadow-md cursor-pointer hover:scale-110 transition-transform"
                        style={{ backgroundColor: color }}
                      />
                    ))}
                  </div>
                  <div className="flex gap-2">
                    <input
                      type="color"
                      value={customColor}
                      onChange={(e) => setCustomColor(e.target.value)}
                      className="w-12 h-10 rounded-lg cursor-pointer"
                    />
                    <button
                      onClick={addColorToPalette}
                      className="flex-1 bg-gray-100 hover:bg-gray-200 rounded-lg text-sm font-medium transition-colors"
                    >
                      Add to Palette
                    </button>
                  </div>
                </div>
                
                <div className="mb-6">
                  <h3 className="font-semibold text-gray-700 mb-3">Burst Pattern</h3>
                  <div className="grid grid-cols-2 gap-2">
                    {[
                      { id: 'explosion', icon: 'ðŸ’¥', name: 'Explosion' },
                      { id: 'fountain', icon: 'â›²', name: 'Fountain' },
                      { id: 'cascade', icon: 'ðŸŒŠ', name: 'Cascade' },
                      { id: 'spiral', icon: 'ðŸŒ€', name: 'Spiral' }
                    ].map(pattern => (
                      <button
                        key={pattern.id}
                        onClick={() => setBurstPattern(pattern.id)}
                        className={`p-3 rounded-lg border-2 transition-all ${
                          burstPattern === pattern.id
                            ? 'border-pink-500 bg-pink-50'
                            : 'border-gray-200 bg-white hover:border-pink-300'
                        }`}
                      >
                        <div className="text-2xl mb-1">{pattern.icon}</div>
                        <div className="text-xs font-medium">{pattern.name}</div>
                      </button>
                    ))}
                  </div>
                  
                  <label className="flex items-center gap-3 mt-3 p-3 bg-gradient-to-r from-purple-50 to-pink-50 rounded-lg cursor-pointer">
                    <input
                      type="checkbox"
                      checked={reverseGravity}
                      onChange={(e) => setReverseGravity(e.target.checked)}
                      className="w-5 h-5 text-purple-600 rounded"
                    />
                    <span className="font-medium text-gray-700">ðŸš€ Reverse Gravity (Float Up!)</span>
                  </label>
                </div>
                
                <div className="mb-6 space-y-4">
                  <h3 className="font-semibold text-gray-700 mb-3">Physics & Intensity</h3>
                  
                  <div>
                    <label className="text-sm text-gray-600 mb-2 block">
                      Particle Count: {particleCount}
                    </label>
                    <input
                      type="range"
                      min="20"
                      max="300"
                      value={particleCount}
                      onChange={(e) => setParticleCount(Number(e.target.value))}
                      className="w-full"
                    />
                  </div>
                  
                  <div>
                    <label className="text-sm text-gray-600 mb-2 block">
                      Gravity: {gravity.toFixed(2)}
                    </label>
                    <input
                      type="range"
                      min="0.01"
                      max="2"
                      step="0.05"
                      value={gravity}
                      onChange={(e) => setGravity(Number(e.target.value))}
                      className="w-full"
                    />
                  </div>
                  
                  <div>
                    <label className="text-sm text-gray-600 mb-2 block">
                      Spread: {spread}
                    </label>
                    <input
                      type="range"
                      min="2"
                      max="15"
                      value={spread}
                      onChange={(e) => setSpread(Number(e.target.value))}
                      className="w-full"
                    />
                  </div>
                </div>
                
                <div className="mb-8">
                  <h3 className="font-semibold text-gray-700 mb-3">Custom Button Image</h3>
                  <input
                    type="text"
                    placeholder="Enter image URL (leave blank for default)"
                    value={buttonImage}
                    onChange={(e) => setButtonImage(e.target.value)}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg"
                  />
                </div>
              </div>
            </div>
          )}
          
          {!showControls && (
            <button
              onClick={() => setShowControls(true)}
              className="absolute top-4 right-4 w-12 h-12 bg-purple-500 text-white rounded-full flex items-center justify-center shadow-lg hover:bg-purple-600 transition-colors z-20"
            >
              <Settings className="w-6 h-6" />
            </button>
          )}
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<ConfettiGenerator />);
  </script>
</body>
</html>